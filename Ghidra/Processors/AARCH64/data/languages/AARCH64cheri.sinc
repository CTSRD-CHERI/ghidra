# New instructions in Morello
# TODO: for the sake of maintenance convenience, let me only reason with addresses and abstract away (some) cap operations 
# TODO: some instructions don't produce pcode

# Morello add/subtract capability
:add Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_posimm_lsl0
is toplevel.op0=0 & toplevel=0x2 & b_23=0 & b_22=0 & morello_imm12_addsubimm_operand_i64_posimm_lsl0 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=1 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp + morello_imm12_addsubimm_operand_i64_posimm_lsl0;
	# if cap is sealed, clear tag bit
	tmp:1 = CapIsSealed(Rd_GPR129csp);
	if (!tmp) goto <skip>;
	Rd_GPR129csp = CapWithTagClear(Rd_GPR129csp);
<skip>
}
:add Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_posimm_lsl0
is toplevel.op0=0 & toplevel=0x2 & b_23=0 & b_22=0 & morello_imm12_addsubimm_operand_i64_posimm_lsl0 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=0 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp + morello_imm12_addsubimm_operand_i64_posimm_lsl0;
}

:add Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_posimm_lsl12
is toplevel.op0=0 & toplevel=0x2 & b_23=0 & b_22=1 & morello_imm12_addsubimm_operand_i64_posimm_lsl12 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=1 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp + morello_imm12_addsubimm_operand_i64_posimm_lsl12;
	# if cap is sealed, clear tag bit
	tmp:1 = CapIsSealed(Rd_GPR129csp);
	if (!tmp) goto <skip>;
	Rd_GPR129csp = CapWithTagClear(Rd_GPR129csp);
<skip>
}
:add Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_posimm_lsl12
is toplevel.op0=0 & toplevel=0x2 & b_23=0 & b_22=1 & morello_imm12_addsubimm_operand_i64_posimm_lsl12 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=0 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp + morello_imm12_addsubimm_operand_i64_posimm_lsl12;
}

:sub Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_negimm_lsl0
is toplevel.op0=0 & toplevel=0x2 & b_23=1 & b_22=0 & morello_imm12_addsubimm_operand_i64_negimm_lsl0 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=1 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp - morello_imm12_addsubimm_operand_i64_negimm_lsl0;
	# if cap is sealed, clear tag bit
	tmp:1 = CapIsSealed(Rd_GPR129csp);
	if (!tmp) goto <skip>;
	Rd_GPR129csp = CapWithTagClear(Rd_GPR129csp);
<skip>
}
:sub Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_negimm_lsl0
is toplevel.op0=0 & toplevel=0x2 & b_23=1 & b_22=0 & morello_imm12_addsubimm_operand_i64_negimm_lsl0 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=0 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp - morello_imm12_addsubimm_operand_i64_negimm_lsl0;
}

:sub Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_negimm_lsl12
is toplevel.op0=0 & toplevel=0x2 & b_23=1 & b_22=1 & morello_imm12_addsubimm_operand_i64_negimm_lsl12 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=1 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp - morello_imm12_addsubimm_operand_i64_negimm_lsl12;
	# if cap is sealed, clear tag bit
	tmp:1 = CapIsSealed(Rd_GPR129csp);
	if (!tmp) goto <skip>;
	Rd_GPR129csp = CapWithTagClear(Rd_GPR129csp);
<skip>
}
:sub Rd_GPR129csp, Rn_GPR129csp, morello_imm12_addsubimm_operand_i64_negimm_lsl12
is toplevel.op0=0 & toplevel=0x2 & b_23=1 & b_22=1 & morello_imm12_addsubimm_operand_i64_negimm_lsl12 & Rn_GPR129csp & Rd_GPR129csp & ShowC64=0 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp - morello_imm12_addsubimm_operand_i64_negimm_lsl12;
}

# Morello load/exclusive (toplevel.op0=0x1 & toplevel=0x2 & b_23=0)
:stxr Rs_GPR32, Rt_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=0 & b_21=0 & b_15=0 & b_1014=0b11111 & Rs_GPR32 & Rt_GPR129 & addrReg & Rs_GPR64 & Rt_GPR64
{
	status:1 = 1;
	rsize:1 = 16;
	check:1 = ExclusiveMonitorPass(addrReg, rsize);
	if (!check) goto <fail>;
	*:8 addrReg = Rt_GPR64;
	status = ExclusiveMonitorsStatus();
<fail>
	Rs_GPR64 = zext(status);
}

:stlxr Rs_GPR32, Rt_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=0 & b_21=0 & b_15=1 & b_1014=0b11111 & Rs_GPR32 & Rt_GPR129 & addrReg & Rs_GPR64 & Rt_GPR64
{
	status:1 = 1;
	rsize:1 = 16;
	check:1 = ExclusiveMonitorPass(addrReg, rsize);
	if (!check) goto <fail>;
	*:8 addrReg = Rt_GPR64;
	status = ExclusiveMonitorsStatus();
<fail>
	Rs_GPR64 = zext(status);
}

:stxp Rs_GPR32, Rt_GPR129, Rt2_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=0 & b_21=1 & b_15=0 & Rs_GPR32 & Rt_GPR129 & addrReg & Rt2_GPR129 & Rs_GPR64 & Rt_GPR64 & Rt2_GPR64
{
	status:1 = 1;
	rsize:1 = 16;
	check:1 = ExclusiveMonitorPass(addrReg, rsize);
	if (!check) goto <fail>;
	*:8 addrReg = Rt_GPR64;
	*:8 (addrReg + 16) = Rt2_GPR64;
	status = ExclusiveMonitorsStatus();
<fail>
	Rs_GPR64 = zext(status);
}

:stlxp Rs_GPR32, Rt_GPR129, Rt2_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=0 & b_21=1 & b_15=1 & Rs_GPR32 & Rt_GPR129 & addrReg & Rt2_GPR129 & Rs_GPR64 & Rt_GPR64 & Rt2_GPR64
{
	status:1 = 1;
	rsize:1 = 16;
	check:1 = ExclusiveMonitorPass(addrReg, rsize);
	if (!check) goto <fail>;
	*:8 addrReg = Rt_GPR64;
	*:8 (addrReg + 16) = Rt2_GPR64;
	status = ExclusiveMonitorsStatus();
<fail>
	Rs_GPR64 = zext(status);
}

:ldxr Rt_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_15=0 & b_1014=0b11111 & b_1620=0b11111 & Rt_GPR129 & addrReg & Rt_GPR64
{
	Rt_GPR64 = *:8 addrReg;
}

:ldaxr Rt_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_15=1 & b_1014=0b11111 & b_1620=0b11111 & Rt_GPR129 & addrReg & Rt_GPR64
{
	Rt_GPR64 = *:8 addrReg;
}

:ldxp Rt_GPR129, Rt2_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_15=0 & b_1620=0b11111 & Rt_GPR129 & Rt2_GPR129 & addrReg & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 addrReg;
	Rt2_GPR64 = *:8 (addrReg + 16);
}

:ldaxp Rt_GPR129, Rt2_GPR129, addrReg
is toplevel.op0=0x1 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_15=1 & b_1620=0b11111 & Rt_GPR129 & Rt2_GPR129 & addrReg & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 addrReg;
	Rt2_GPR64 = *:8 (addrReg + 16);
}

# Morello load/store pair postindex (toplevel.op0=0x1 & toplevel=0x2 & b_23=1)
:stp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0x1 & toplevel=0x2 & b_23=1 & b_22=0 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	build CAddrPairIndexed;
	*:8 CAddrPairIndexed = Rt_GPR64;
	*:8 (CAddrPairIndexed + 16) = Rt2_GPR64;
}

:ldp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0x1 & toplevel=0x2 & b_23=1 & b_22=1 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 CAddrPairIndexed;
	Rt2_GPR64 = *:8 (CAddrPairIndexed + 16);
}

# Morello load/store acquire/release capability via alternate base (toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=0)
:stlr Rt_GPR129, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=0 & b_22=0 & b_1620=0b11111 & b_1014=0b11111 & Rt_GPR129 & addrReg & Rt_GPR64
{
	*:8 addrReg = Rt_GPR64;
}

:ldar Rt_GPR129, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=0 & b_22=1 & b_1620=0b11111 & b_1014=0b11111 & Rt_GPR129 & addrReg & Rt_GPR64
{
	Rt_GPR64 = *:8 addrReg;
}

# Morello load/store acquire/release (toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=1)
:stlr Rt_GPR129, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=1 & b_1620=0b11111 & b_1014=0b11111 & b_22=0 & Rt_GPR129 & addrReg & Rt_GPR64
{
	*:8 addrReg = Rt_GPR64;
}

:ldar Rt_GPR129, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=0 & b_15=1 & b_1620=0b11111 & b_1014=0b11111 & b_22=1 & Rt_GPR129 & addrReg & Rt_GPR64
{
	Rt_GPR64 = *:8 addrReg;
}

# Morello load/store acquire/release via alternate base (toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=1)
:stlrb Rt_GPR32, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=1 & b_22=0 & b_1620=0b11111 & b_15=0 & b_1014=0b11111 & Rt_GPR32 & addrReg
{
	data:4 = Rt_GPR32;
	*addrReg = data:1;
}

:stlr Rt_GPR32, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=1 & b_22=0 & b_1620=0b11111 & b_15=1 & b_1014=0b11111 & Rt_GPR32 & addrReg
{
	*addrReg = Rt_GPR32;
}

:ldarb Rt_GPR32, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=1 & b_22=1 & b_1620=0b11111 & b_15=0 & b_1014=0b11111 & Rt_GPR32 & addrReg & Rt_GPR129
{
	Rt_GPR129 = zext(*:1 addrReg);
}

:ldar Rt_GPR32, addrReg
is toplevel.op0=0b10 & toplevel=0x2 & b_23=0 & b_21=1 & b_22=1 & b_1620=0b11111 & b_15=1 & b_1014=0b11111 & Rt_GPR32 & addrReg & Rt_GPR129
{
	Rt_GPR129 = zext(*:4 addrReg);
}

# Morello load/store pair (toplevel.op0=0b10 & toplevel=0x2 & b_23=1)
:stp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b10 & toplevel=0x2 & b_23=1 & b_22=0 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	build CAddrPairIndexed;
	*:8 CAddrPairIndexed = Rt_GPR64;
	*:8 (CAddrPairIndexed + 16) = Rt2_GPR64;
}

:ldp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b10 & toplevel=0x2 & b_23=1 & b_22=1 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 CAddrPairIndexed;
	Rt2_GPR64 = *:8 (CAddrPairIndexed + 16);
}

# Morello load/store pair non-temporal (toplevel.op0=0b11 & toplevel=0x2 & b_23=0)
:stnp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b11 & toplevel=0x2 & b_23=0 & b_22=0 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	build CAddrPairIndexed;
	*:8 CAddrPairIndexed = Rt_GPR64;
	*:8 (CAddrPairIndexed + 16) = Rt2_GPR64;
}

:ldnp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b11 & toplevel=0x2 & b_23=0 & b_22=1 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 CAddrPairIndexed;
	Rt2_GPR64 = *:8 (CAddrPairIndexed + 16);
}

#Â Morello load/store pair preindex (toplevel.op0=0b11 & toplevel=0x2 & b_23=1)
:stp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b11 & toplevel=0x2 & b_23=1 & b_22=0 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	build CAddrPairIndexed;
	*:8 CAddrPairIndexed = Rt_GPR64;
	*:8 (CAddrPairIndexed + 16) = Rt2_GPR64;
}

:ldp Rt_GPR129, Rt2_GPR129, CAddrPairIndexed
is toplevel.op0=0b11 & toplevel=0x2 & b_23=1 & b_22=1 & Rt_GPR129 & Rt2_GPR129 & CAddrPairIndexed & Rt_GPR64 & Rt2_GPR64
{
	Rt_GPR64 = *:8 CAddrPairIndexed;
	Rt2_GPR64 = *:8 (CAddrPairIndexed + 16);
}

# LDR (literal) (toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=0)
:ldr Rt_GPR129, AddrLoc17
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=0 & Rt_GPR129 & AddrLoc17 & Rt_GPR64
{
	Rt_GPR64 = *:8 AddrLoc17;
	# Rt_GPR129 = *:16 AddrLoc17;
}

# Morello load/store unsigned offset via alternate base (toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1)
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_1011=0 & CAddrIndexed & Rt_GPR129 & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:strb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_1011=1 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1:1;
}

:str Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_1011=2 & CAddrIndexed & Rt_GPR32
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

:str Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=0 & b_1011=3 & CAddrIndexed & Rt_GPR64
{
	data1:8 = Rt_GPR64;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_1011=0 & CAddrIndexed & Rt_GPR129 & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
	# Rt_GPR64 = *:8 CAddrIndexed;
}

:ldrb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_1011=1 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:1 CAddrIndexed);
}

:ldr Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_1011=2 & CAddrIndexed & Rt_GPR32 & Rt_GPR129
{
	Rt_GPR129 = zext(*:4 CAddrIndexed);
}

:ldr Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=0 & b_22=1 & b_21=1 & b_1011=3 & CAddrIndexed & Rt_GPR64 & Rt_GPR129
{
	Rt_GPR129 = zext(*:8 CAddrIndexed);
}

# Morello load/store register via alternate base (toplevel.op0=0b100 & toplevel=0x2 & b_23=1)
# scale = 0
:strb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=0 & b_1011=0 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1:1;
}

# 0
:ldrsb Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=0 & b_1011=1 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:1 CAddrIndexed);
}

# 1
:ldrsh Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=0 & b_1011=2 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:2 CAddrIndexed);
}

# 1
:strh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=0 & b_1011=3 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1:2;
}

# 2
:str Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=1 & b_1011=0 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

# 3
:str Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=1 & b_1011=1 & Rt_GPR64 & CAddrIndexed
{
	data1:8 = Rt_GPR64;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

# 3
:str Rt_FPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=1 & b_1011=2 & Rt_FPR64 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR64;
}

# 2
:str Rt_FPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=0 & b_21=1 & b_1011=3 & Rt_FPR32 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR32;
}

# 0
:ldrb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=0 & b_1011=0 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:1 CAddrIndexed);
}

# 0
:ldrsb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=0 & b_1011=1 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:1 CAddrIndexed);
}

# 1
:ldrsh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=0 & b_1011=2 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:2 CAddrIndexed);
}

# 1
:ldrh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=0 & b_1011=3 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:2 CAddrIndexed);
}

# 2
:ldr Rt_GPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=1 & b_1011=0 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:4 CAddrIndexed);
}

# 3
:ldr Rt_GPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=1 & b_1011=1 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:8 CAddrIndexed);
}

# 3
:ldr Rt_FPR64, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=1 & b_1011=2 & Rt_FPR64 & CAddrIndexed & Zt
{
	Rt_FPR64 = *CAddrIndexed;
	zext_zd(Zt); # zero upper 24 bytes of Zt
}

# 2
:ldr Rt_FPR32, CAddrIndexed
is toplevel.op0=0b100 & toplevel=0x2 & b_23=1 & b_22=1 & b_21=1 & b_1011=3 & Rt_FPR32 & CAddrIndexed & Zt
{
	Rt_FPR32 = *CAddrIndexed;
	zext_zs(Zt); # zero upper 28 bytes of Zt
}

# Morello load/store unscaled immediate (toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=0)
:stur Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=0 & b_2223=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldur Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=0 & b_2223=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello load/store immediate postindex (toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=1)
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=1 & b_2223=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=1 & b_2223=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello load/store immediate translated (toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=2)
:sttr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=2 & b_2223=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldtr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=2 & b_2223=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello load/store immediate preindex (toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=3)
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=3 & b_2223=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=0 & b_1011=3 & b_2223=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
	# Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello swap (toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b100000)
:swp aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b100000 & b_2223=0 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	tmp_ldCn = *:16 Rn_GPR64xsp;
	tmp_stCn = aa_Cs;
	*:16 Rn_GPR64xsp = tmp_stCn;
	aa_Ct = tmp_ldCn;
}

:swpl aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b100000 & b_2223=1 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	tmp_ldCn = *:16 Rn_GPR64xsp;
	tmp_stCn = aa_Cs;
	*:16 Rn_GPR64xsp = tmp_stCn;
	aa_Ct = tmp_ldCn;
	LORelease();
}

:swpa aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b100000 & b_2223=2 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	LOAcquire();
	tmp_ldCn = *:16 Rn_GPR64xsp;
	tmp_stCn = aa_Cs;
	*:16 Rn_GPR64xsp = tmp_stCn;
	aa_Ct = tmp_ldCn;
}

:swpal aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b100000 & b_2223=3 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	LOAcquire();
	tmp_ldCn = *:16 Rn_GPR64xsp;
	tmp_stCn = aa_Cs;
	*:16 Rn_GPR64xsp = tmp_stCn;
	aa_Ct = tmp_ldCn;
	LORelease();
}

# LDAPR (toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b110000)
:ldapr aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1015=0b110000 & aa_Ct & CAddrReg
{
	aa_Ct = tmp_ldCn;
}

# Morello compare and swap (toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1014=0b11111)
:cas aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1014=0b11111 & b_2223=2 & b_15=0 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	comparevalue:16 = aa_Cs;
	newvalue:16 = aa_Ct;
	data:16 = *:16 Rn_GPR64xsp;
	if (data != comparevalue) goto <skip>;
	*:16 Rn_GPR64xsp = newvalue;
<skip>
	aa_Cs = data;
}

:casl aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1014=0b11111 & b_2223=2 & b_15=1 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	comparevalue:16 = aa_Cs;
	newvalue:16 = aa_Ct;
	data:16 = *:16 Rn_GPR64xsp;
	if (data != comparevalue) goto <skip>;
	*:16 Rn_GPR64xsp = newvalue;
<skip>
	aa_Cs = data;
}

:casa aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1014=0b11111 & b_2223=3 & b_15=0 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	comparevalue:16 = aa_Cs;
	newvalue:16 = aa_Ct;
	data:16 = *:16 Rn_GPR64xsp;
	if (data != comparevalue) goto <skip>;
	*:16 Rn_GPR64xsp = newvalue;
<skip>
	aa_Cs = data;
}

:casal aa_Cs, aa_Ct, CAddrReg
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_1014=0b11111 & b_2223=3 & b_15=1 & aa_Cs & aa_Ct & CAddrReg & Rn_GPR64xsp
{
	comparevalue:16 = aa_Cs;
	newvalue:16 = aa_Ct;
	data:16 = *:16 Rn_GPR64xsp;
	if (data != comparevalue) goto <skip>;
	*:16 Rn_GPR64xsp = newvalue;
<skip>
	aa_Cs = data;
}

# Morello load/store register (toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_14=1 & b_1011=2)
# scale=4
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_14=1 & b_1011=2 & b_2223=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

# scale=4
:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b101 & toplevel=0x2 & b_21=1 & b_14=1 & b_1011=2 & b_2223=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
	# Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello load/store unsigned offset (toplevel.op0=0b110 & toplevel=0x2 & b_23=0)
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b110 & toplevel=0x2 & b_23=0 & b_22=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b110 & toplevel=0x2 & b_23=0 & b_22=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
	# Rt_GPR64 = *:8 CAddrIndexed;
}

# Morello get/set system register (toplevel.op0=0b110 & toplevel=0x2 & b_2123=0b100)
CopReg: "sreg("^Op0^", "^Op1_uimm3^", c"^CRn^", c"^CRm^", "^Op2_uimm3^")" is l=0 & Op0 & Op1_uimm3 & CRn & CRm & Op2_uimm3 & Rt_GPR64 { tmp:8 = UnkSytemRegWrite(Op0:1, Op1_uimm3:1, CRn:1, CRm:1, Op2_uimm3:1, Rt_GPR64); export tmp; }

:msr CopReg, Rt_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2123=0b100 & b_20=0 & CopReg & Rt_GPR64
{}

:mrs Rt_GPR64, CopReg
is toplevel.op0=0b110 & toplevel=0x2 & b_2123=0b100 & b_20=1 & CopReg & Rt_GPR64
{}

# ADD (extended register) (toplevel.op0=0b110 & toplevel=0x2 & b_2123=0b101)
:add Rd_GPR129csp, Rn_GPR129csp, ExtendRegShift64
is toplevel.op0=0b110 & toplevel=0x2 & b_2123=0b101 & Rd_GPR129csp & Rn_GPR129csp & ExtendRegShift64 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR64xsp = Rn_GPR64xsp + ExtendRegShift64;
}

# Morello load/store unscaled immediate via alternate base (toplevel.op0=0b111 & toplevel=0x2)
:sturb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=0 & b_21=0 & b_1011=0 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1:1;
}

:ldurb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=0 & b_21=0 & b_1011=1 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:1 CAddrIndexed);
}

:ldursb Rt_GPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=0 & b_21=0 & b_1011=2 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:1 CAddrIndexed);
}

:ldursb Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=0 & b_21=0 & b_1011=3 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:1 CAddrIndexed);
}

:sturh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=1 & b_21=0 & b_1011=0 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1:2;
}

:ldurh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=1 & b_21=0 & b_1011=1 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:2 CAddrIndexed);
}

:ldursh Rt_GPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=1 & b_21=0 & b_1011=2 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:2 CAddrIndexed);
}

:ldursh Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=1 & b_21=0 & b_1011=3 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:2 CAddrIndexed);
}

### FP&SIMD
#### 8-bit
:stur Rt_FPR8, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=0 & b_1011=0 & Rt_FPR8 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR8;
}

:ldur Rt_FPR8, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=0 & b_1011=1 & Rt_FPR8 & CAddrIndexed & Zt
{
	Rt_FPR8 = *CAddrIndexed;
	zext_zb(Zt); # zero upper 31 bytes of Zt
}

#### 16-bit
:stur Rt_FPR16, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=1 & b_1011=0 & Rt_FPR16 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR16;
}

:ldur Rt_FPR16, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=1 & b_1011=1 & Rt_FPR16 & CAddrIndexed & Zt
{
	Rt_FPR16 = *CAddrIndexed;
	zext_zh(Zt); # zero upper 30 bytes of Zt
}

#### 32-bit
:stur Rt_FPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=2 & b_1011=0 & Rt_FPR32 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR32;
}

:ldur Rt_FPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=2 & b_1011=1 & Rt_FPR32 & CAddrIndexed & Zt
{
	Rt_FPR32 = *CAddrIndexed;
	zext_zs(Zt); # zero upper 28 bytes of Zt
}

#### 64-bit
:stur Rt_FPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=3 & b_1011=0 & Rt_FPR64 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR64;
}

:ldur Rt_FPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=3 & b_1011=1 & Rt_FPR64 & CAddrIndexed & Zt
{
	Rt_FPR64 = *CAddrIndexed;
	zext_zd(Zt); # zero upper 24 bytes of Zt
}

#### 128-bit
:stur Rt_FPR128, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=0 & b_1011=2 & Rt_FPR128 & CAddrIndexed
{
	*CAddrIndexed = Rt_FPR128;
}

:ldur Rt_FPR128, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_21=1 & b_2223=0 & b_1011=3 & Rt_FPR128 & CAddrIndexed & Zt
{
	Rt_FPR128 = *CAddrIndexed;
	zext_zq(Zt); # zero upper 16 bytes of Zt
}

### Integer
:stur Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=2 & b_21=0 & b_1011=0 & Rt_GPR32 & CAddrIndexed
{
	data1:4 = Rt_GPR32;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

:stur Rt_GPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=3 & b_21=0 & b_1011=0 & Rt_GPR64 & CAddrIndexed
{
	data1:8 = Rt_GPR64;
	build CAddrIndexed;
	*CAddrIndexed = data1;
}

:ldur Rt_GPR32, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=2 & b_21=0 & b_1011=1 & Rt_GPR32 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:4 CAddrIndexed);
}

:ldur Rt_GPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=3 & b_21=0 & b_1011=1 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = zext(*:8 CAddrIndexed);
}

### Capability, alternate base
:stur Rt_GPR129, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=2 & b_21=0 & b_1011=3 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

:ldur Rt_GPR129, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=3 & b_21=0 & b_1011=3 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
}

:ldursw Rt_GPR64, CAddrIndexed
is toplevel.op0=0b111 & toplevel=0x2 & b_2223=2 & b_21=0 & b_1011=2 & Rt_GPR64 & CAddrIndexed & Rt_GPR129
{
	Rt_GPR129 = sext(*:4 CAddrIndexed);
}

# Morello misc (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11)

## Morello get field 1 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0)
:gcbase Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=0 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetBounds(Rn_GPR129csp);
}

:gclen Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=1 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetLength(Rn_GPR129csp);
}

:gcvalue Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=2 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetValue(Rn_GPR129csp);
}

:gcoff Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=3 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetOffset(Rn_GPR129csp);
}

:gctag Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=4 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapIsTagSet(Rn_GPR129csp);
}

:gcseal Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=5 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapIsSealed(Rn_GPR129csp);
}

:gcperm Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=6 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetPermissions(Rn_GPR129csp);
}

:gctype Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=0 & b_1112=2 & b_10=0 & b_1315=7 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetObjectType(Rn_GPR129csp);
}

## Morello get field 2 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=2 & b_1112=2 & b_10=0)
:gclim Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=2 & b_1112=2 & b_10=0 & b_1314=0 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetBoundsLimit(Rn_GPR129csp);
}

:gcflgs Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=2 & b_1112=2 & b_10=0 & b_1314=1 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = CapGetFlags(Rn_GPR129csp);
}

:cfhi Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=2 & b_1112=2 & b_10=0 & b_1314=2 & Rd_GPR64 & Rn_GPR129csp
{
	Rd_GPR64 = Rn_GPR129csp[64,64];
}

## Morello miscellaneous capability 0 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=2 & b_10=0 & b_1521=0b11)
:clrtag Rd_GPR129csp, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=2 & b_10=0 & b_1521=0b11 & b_1314=0 & Rd_GPR129csp & Rn_GPR129csp & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapWithTagClear(Rn_GPR129csp);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

# preferred over CPY 
:mov Rd_GPR129csp, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=2 & b_10=0 & b_1521=0b11 & b_1314=2 & Rd_GPR129csp & Rn_GPR129csp
{
	Rd_GPR129csp = Rn_GPR129csp;
}

## Morello branch (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=0)
# BR (indirect)
:br Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=0 & b_1314=0 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	goto [pc];
}

# BLR (indirect)
:blr Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=0 & b_1314=1 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	x30 = inst_start + 4;
	call [pc];
}

:ret Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=0 & b_1314=2 & Rn_GPR129 & Rn_GPR64
{
    pc = Rn_GPR64;
	return [pc];
}

:bx "#4"
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=0 & b_1314=3 & b_0509=0b11111
{
	pc = pc + 4;
	goto [pc];
}

## Morello checks (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=1)
:chksld Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=1 & b_1314=0 & Rn_GPR129csp
{}

:chktgd Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=1 & b_1314=1 & Rn_GPR129csp
{}

## Morello branch sealed direct (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=2)
# BRS (capability)
:brs Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=2 & b_1314=0 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	goto [pc];
}

# BLRS (capability)
:blrs Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=2 & b_1314=1 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	x30 = inst_start + 4;
	call [pc];
}

# RETS (capability)
:rets Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=2 & b_1314=2 & Rn_GPR129 & Rn_GPR64
{
    pc = Rn_GPR64;
	return [pc];
}

## Morello branch restricted (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=3)
:brr Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=3 & b_1314=0 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	goto [pc];
}

:blrr Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=3 & b_1314=1 & Rn_GPR129 & Rn_GPR64
{
	pc = Rn_GPR64;
	x30 = inst_start + 4;
	call [pc];
}

:retr Rn_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=4 & b_1112=2 & b_10=0 & b_0004=3 & b_1314=2 & Rn_GPR129 & Rn_GPR64
{
    pc = Rn_GPR64;
	return [pc];
}

## SEAL (immediate) 
:seal Rd_GPR129, Rn_GPR129, form
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=6 & b_1112=2 & b_10=0 & Rd_GPR129 & Rn_GPR129 & form & Rd_GPR64 & Rn_GPR64
{
	Rd_GPR129 = CapSetObjectType(Rn_GPR129, form);
	Rd_GPR64 = Rn_GPR64;
}

## Morello load pair and branch (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=8 & b_1112=2 & b_10=0)
:ldpbr Rt_GPR129, CAddrReg
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=8 & b_1112=2 & b_10=0 & b_1314=0 & Rt_GPR129 & CAddrReg
{}

:ldpblr Rt_GPR129, CAddrReg
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=8 & b_1112=2 & b_10=0 & b_1314=1 & Rt_GPR129 & CAddrReg
{}

## Morello load/store tags (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=9 & b_1112=2 & b_10=0)
:stct Rt_GPR64, CAddrReg
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=9 & b_1112=2 & b_10=0 & b_1314=0 & Rt_GPR64 & CAddrReg
{}

:ldct Rt_GPR64, CAddrReg
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=9 & b_1112=2 & b_10=0 & b_1314=1 & Rt_GPR64 & CAddrReg
{}

## Morello convert to pointer (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=10 & b_1112=2 & b_10=0)
# CVTD (to pointer)
:cvtd Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=10 & b_1112=2 & b_10=0 & b_1314=0 & Rd_GPR64 & Rn_GPR129csp
{}

# CVTP (to pointer)
:cvtp Rd_GPR64, Rn_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=10 & b_1112=2 & b_10=0 & b_1314=1 & Rd_GPR64 & Rn_GPR129csp
{}

## Morello convert to capability with implicit operand (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=11 & b_1112=2 & b_10=0)
# CVTD (to capability)
:cvtd Rd_GPR129, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=11 & b_1112=2 & b_10=0 & b_1314=0 & Rd_GPR129 & Rn_GPR64
{}

# CVTP (to capability)
:cvtp Rd_GPR129, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=11 & b_1112=2 & b_10=0 & b_1314=1 & Rd_GPR129 & Rn_GPR64
{}

:cvtdz Rd_GPR129, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=11 & b_1112=2 & b_10=0 & b_1314=2 & Rd_GPR129 & Rn_GPR64
{}

:cvtpz Rd_GPR129, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=11 & b_1112=2 & b_10=0 & b_1314=3 & Rd_GPR129 & Rn_GPR64
{}

## CLRPERM (immediate)
:clrperm Rd_GPR129csp, Rn_GPR129csp, perm
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1621=6 & b_1112=2 & b_10=0 & Rd_GPR129csp & Rn_GPR129csp & perm & Rd_GPR64 & Rn_GPR64
{
	Rd_GPR129csp = CapClearPerms(Rn_GPR129csp, perm);
	Rd_GPR64 = Rn_GPR64;
}

## Morello 1 src 1 dest (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=14 & b_1112=2 & b_10=0)
:rrlen Rd_GPR64, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=14 & b_1112=2 & b_10=0 & b_1314=0 & Rd_GPR64 & Rn_GPR64
{}

:rrmask Rd_GPR64, Rn_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1521=14 & b_1112=2 & b_10=0 & b_1314=1 & Rd_GPR64 & Rn_GPR64
{}

## Morello branch sealed indirect (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_2021=1 & b_1112=2 & b_10=0 & b_0104=0)
# BR (memory indirect)
:br "["^Rn_GPR129csp, "#"^pimm^"]"
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_2021=1 & b_1112=2 & b_10=0 & b_0104=0 & b_00=0 & Rn_GPR129csp & morello.simm7 & Rn_GPR64
[ pimm = morello.simm7 << 4; ]
{
	# TODO: if C29, save the base address
	pc = *:8 (Rn_GPR64 + pimm);
	goto [pc];
}

# BLR (memory indirect)
:blr "["^Rn_GPR129csp, "#"^pimm^"]"
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_2021=1 & b_1112=2 & b_10=0 & b_0104=0 & b_00=1 & Rn_GPR129csp & morello.simm7 & Rn_GPR64
[ pimm = morello.simm7 << 4; ]
{
	# TODO: if C29, save the base address
	pc = *:8 (Rn_GPR64 + pimm);
	x30 = inst_start + 4;
	call [pc];
}

## Morello set field 1 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=0 & b_21=0)
# SCBNDS (register)
:scbnds Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=0 & b_21=0 & b_1314=0 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapSetBounds(Rn_GPR129csp, Rm_GPR64);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

:scbndse Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=0 & b_21=0 & b_1314=1 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapSetBoundsExact(Rn_GPR129csp, Rm_GPR64);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

:scvalue Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=0 & b_21=0 & b_1314=2 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapSetValue(Rn_GPR129csp, Rm_GPR64);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

:scoff Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=0 & b_21=0 & b_1314=3 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapSetOffset(Rn_GPR129csp, Rm_GPR64);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

## Morello miscellaneous capability 1 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=0 & b_21=0)
:build Rd_GPR129csp, Rn_GPR129csp, Rm_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=0 & b_21=0 & b_1314=0 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR129csp & Rd_GPR64xsp & Rn_GPR64xsp
{
	Rd_GPR129csp = CapWithTagSet(Rn_GPR129csp);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

:cpytype Rd_GPR129, Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=0 & b_21=0 & b_1314=1 & Rd_GPR129 & Rn_GPR129 & Rm_GPR129 & Rd_GPR64 & Rn_GPR64
{
	type:8 = CapGetObjectType(Rm_GPR129);
	Rd_GPR129 = CapSetValue(Rn_GPR129, type);
	Rd_GPR64 = Rn_GPR64;
}

:cseal Rd_GPR129csp, Rn_GPR129csp, Rm_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=0 & b_21=0 & b_1314=2 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR129csp & Rd_GPR64xsp & Rn_GPR64xsp
{
	otype:8 = CapGetValue(Rm_GPR129csp);
	Rd_GPR129csp = CapSetObjectType(Rn_GPR129csp, otype);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

:cpyvalue Rd_GPR129, Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=0 & b_21=0 & b_1314=3 & Rd_GPR129 & Rn_GPR129 & Rm_GPR129 & Rd_GPR64 & Rn_GPR64
{
	type:8 = CapGetValue(Rm_GPR129);
	Rd_GPR129 = CapSetValue(Rn_GPR129, type);
	Rd_GPR64 = Rn_GPR64;
}

## Morello set field 2 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=1 & b_21=0 & b_14=0)
:sctag Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=1 & b_21=0 & b_14=0 & b_13=0 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rn_GPR64xsp & Rd_GPR64xsp
{
	newtag:1 = Rm_GPR64:1;
	if (!newtag) goto <fail>;
	Rd_GPR129csp = CapWithTagSet(Rn_GPR129csp);
	goto <end>;
<fail>
	Rd_GPR129csp = CapWithTagClear(Rn_GPR129csp);
<end>
	Rd_GPR64xsp = Rn_GPR64xsp;
}

# CLRPERM (register)
:clrperm Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_15=1 & b_21=0 & b_14=0 & b_13=1 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64 & Rn_GPR64xsp & Rd_GPR64xsp
{
	Rd_GPR129csp = CapClearPerms(Rn_GPR129csp, Rm_GPR64);
	Rd_GPR64xsp = Rn_GPR64xsp;
}

## CVT (to pointer)
:cvt Rd_GPR64, Rn_GPR129csp, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_1315=0b110 & b_21=0 & Rd_GPR64 & Rn_GPR129csp & Rm_GPR129
{}

## SCFLGS
:scflgs Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=0 & b_1315=0b111 & b_21=0 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64
{}

## Morello branch to sealed (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=0)
# BRS (pair of capabilities)
:brs "c29", Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=0 & b_1314=0 & Rn_GPR129 & Rm_GPR129 & Rn_GPR64
{
	c29 = Rm_GPR129;
	pc = Rn_GPR64;
	goto [pc];
}

# BLRS (pair of capabilities)
:blrs "c29", Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=0 & b_1314=1 & Rn_GPR129 & Rm_GPR129 & Rn_GPR64
{
	c29 = Rm_GPR129;
	pc = Rn_GPR64;
	x30 = inst_start + 4;
	call [pc];
}

# RETS (pair of capabilities)
:rets "c29", Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=0 & b_1314=2 & Rn_GPR129 & Rm_GPR129 & Rn_GPR64
{
	c29 = Rm_GPR129;
    pc = Rn_GPR64;
	return [pc];
}

## Morello 2 src cap (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=1)
:chkss Rn_GPR129csp, Rm_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=1 & b_1314=0 & Rn_GPR129csp & Rm_GPR129csp
{}

:chkeq Rn_GPR129csp, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=0 & b_10=1 & b_15=1 & b_21=0 & b_0004=1 & b_1314=1 & Rn_GPR129csp & Rm_GPR129
{}

## Morello miscellaneous capability 2 (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=0 & b_21=0)
# SEAL (capability)
:seal Rd_GPR129, Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=0 & b_21=0 & b_1415=0 & Rd_GPR129 & Rn_GPR129 & Rm_GPR129 & Rn_GPR64 & Rd_GPR64
{
	type:8 = CapGetValue(Rm_GPR129);
	Rd_GPR129 = CapSetObjectType(Rn_GPR129, type);
	Rd_GPR64 = Rn_GPR64;
}

:unseal Rd_GPR129, Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=0 & b_21=0 & b_1415=1 & Rd_GPR129 & Rn_GPR129 & Rm_GPR129 & Rn_GPR64 & Rd_GPR64
{
	Rd_GPR129 = CapUnseal(Rn_GPR129);
	Rd_GPR64 = Rn_GPR64;
}

:chkssu Rd_GPR129, Rn_GPR129csp, Rm_GPR129csp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=0 & b_21=0 & b_1415=2 & Rd_GPR129 & Rn_GPR129csp & Rm_GPR129csp
{}

## Morello alignment (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=0 & b_21=0)
:alignd Rd_GPR129csp, Rn_GPR129csp, UImm6
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=0 & b_21=0 & b_14=0 & Rd_GPR129csp & Rn_GPR129csp & UImm6
{}

:alignu Rd_GPR129csp, Rn_GPR129csp, UImm6
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=0 & b_21=0 & b_14=1 & Rd_GPR129csp & Rn_GPR129csp & UImm6
{}

## Morello bitwise (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=1 & b_21=0)
# BICFLGS (register)
:bicflgs Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=1 & b_21=0 & b_1415=0 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64
{}

# ORRFLGS (register)
:orrflgs Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=1 & b_21=0 & b_1415=1 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64
{}

# EORFLGS (register)
:eorflgs Rd_GPR129csp, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=1 & b_21=0 & b_1415=2 & Rd_GPR129csp & Rn_GPR129csp & Rm_GPR64
{}

:cthi Rd_GPR129csp, Rn_GPR129, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=1 & b_10=0 & b_13=1 & b_21=0 & b_1415=3 & Rd_GPR129csp & Rn_GPR129 & Rm_GPR64
{}

## Morello immediate bounds (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=1 & b_21=0)
:scbnds Rd_GPR129, Rn_GPR129, UImm6
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=1 & b_21=0 & b_14=0 & Rd_GPR129 & Rn_GPR129 & UImm6 & Rd_GPR64 & Rn_GPR64
{
	bounds:4 = UImm6;
	Rd_GPR129 = CapSetBounds(Rn_GPR129, bounds);
	Rd_GPR64 = Rn_GPR64;
}

:scbnds Rd_GPR129, Rn_GPR129, UImm6, "LSL #4"
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_13=1 & b_21=0 & b_14=1 & Rd_GPR129 & Rn_GPR129 & UImm6 & Rd_GPR64 & Rn_GPR64
{
	bounds:4 = UImm6 << 4;
	Rd_GPR129 = CapSetBounds(Rn_GPR129, bounds);
	Rd_GPR64 = Rn_GPR64;
}

## CSEL
:csel Rd_GPR129, Rn_GPR129, Rm_GPR129, BranchCondOp
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_11=1 & b_10=1 & b_21=0 & Rd_GPR129 & Rn_GPR129 & Rm_GPR129 & BranchCondOp
{
	condition:1 = BranchCondOp;
	tmp:16 = Rn_GPR129;
	if (condition) goto <skip>;
	tmp = Rm_GPR129;
<skip>
	Rd_GPR129 = tmp;
}

## Morello convert to capability (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_21=1 & b_13=0 & b_15=0)
# CVT (to capability)
:cvt Rd_GPR129, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_21=1 & b_13=0 & b_15=0 & b_14=0 & Rd_GPR129 & Rn_GPR129csp & Rm_GPR64
{}

:cvtz Rd_GPR129, Rn_GPR129csp, Rm_GPR64
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_21=1 & b_13=0 & b_15=0 & b_14=1 & Rd_GPR129 & Rn_GPR129csp & Rm_GPR64
{}

## SUBS
:cmp Rd_GPR64, Rn_GPR129, Rm_GPR129
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_1112=3 & b_10=0 & b_21=1 & b_1315=4 & Rd_GPR64 & Rn_GPR129 & Rm_GPR129
{
	tmp_1:2 = CapIsTagSet(Rn_GPR129);
	tmp_2:2 = CapIsTagSet(Rm_GPR129);
	subflags(tmp_1, tmp_2);
	tmp_3:2 = tmp_1 - tmp_2;
	resultflags(tmp_3);
	Rd_GPR64 = zext(tmp_3);
	affectflags();
}

## Morello load/store capability via alternate base (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=1 & b_21=1 & b_14=1)
# STR (register offset, capability, alternate base)
:str Rt_GPR129, CAddrIndexed
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=1 & b_21=1 & b_14=1 & b_11=0 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	build CAddrIndexed;
	*:8 CAddrIndexed = Rt_GPR64;
}

# LDR (register offset, capability, alternate base)
:ldr Rt_GPR129, CAddrIndexed
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=1 & b_21=1 & b_14=1 & b_11=1 & Rt_GPR129 & CAddrIndexed & Rt_GPR64
{
	Rt_GPR64 = *:8 CAddrIndexed;
}

## Morello logical immediate (toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=0 & b_21=1)
# BICFLGS (immediate)
:bicflgs Rd_GPR129csp, Rn_GPR129csp, UImm8
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=0 & b_21=1 & b_1112=0 & Rd_GPR129csp & Rn_GPR129csp & UImm8
{}

# ORRFLGS (immediate)
:orrflgs Rd_GPR129csp, Rn_GPR129csp, UImm8
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=0 & b_21=1 & b_1112=1 & Rd_GPR129csp & Rn_GPR129csp & UImm8
{}

# EORFLGS (immediate)
:eorflgs Rd_GPR129csp, Rn_GPR129csp, UImm8
is toplevel.op0=0b110 & toplevel=0x2 & b_2223=0b11 & b_10=0 & b_21=1 & b_1112=2 & Rd_GPR129csp & Rn_GPR129csp & UImm8
{}
